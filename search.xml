<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前后端跨域问题]]></title>
    <url>%2Fdevelopment%2Fvue_cros%2F</url>
    <content type="text"><![CDATA[最近大三数据库课程设计课大作业是用基于SpringBoot的SSM框架+Vue.js设计一个网站，我们小组开发了一个关于汽车销售的网站，其中遇到很多问题，前后端跨越就是其中之一 前言此项目实践基于Token的WEB后台认证机制，自己了实践一次，采用前后端分离的设计模式，其中出现了前后端跨域失败的问题，所以就有了下文。关于token的生成，另外一篇文章会细讲。本篇主要讨论在发送ajax请求，头部带上自定义token验证验证，暴露出的跨域问题。 定义CORS：跨来源资源共享（CORS）是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比JSONP要来的好，JSONP对于 RESTful 的 API 来说，发送 POST/PUT/DELET 请求将成为问题，不利于接口的统一。但另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。不过现代的浏览器（IE10以上）基本都支持 CORS。预检请求（option）:在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求(一般都是浏览检测到请求跨域时，会自动发起)，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。 12345678910OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。 问题描述话不多说，先上代码： 前端（ajax库：vue-resource） 1234567891011121314151617181920userLogin:function()&#123; this.$http(&#123; method:'post', url:'http://localhost:8089/StockAnalyse/LoginServlet', params&#123; "flag":"ajaxlogin", "loginName":this.userInfo.id, "loginPwd":this.userInfo.psd &#125;, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, credientials:false, emulateJSON: true &#125;).then(function(response)&#123; sessionStorage.setItem("token",response.data); this.isActive =false; document.querySelector("#showInfo").classList.toggle("isLogin"); &#125;) &#125; 后端相关配置： 1234response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost&quot;); //允许来之域名为http://localhost的请求 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin,No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With, userId, token&quot;);response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); //请求允许的方法response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); //身份认证(预检)后，xxS以内发送请求不在需要预检，既可以直接跳过预检，进行请求(前面只是照猫画虎，后面才理解) 关于上面一段代码，是我的用户首次登录认证，生成token令牌，保存在sessionStorage中，供后面调用；需要说明的是，前端服务器地址是：localhost:8081,后端服务器地址：localhost:8080，所以前后端涉及到跨域，自己在后端做了相应的跨域设置：response.setHeader(“Access-Control-Allow-Origin”, “http://localhost&quot;); 所以登录认证,安全的实现了跨域信息认证，后端相应发送回来了相应的token信息。但获取到token后，想在需要的时候，在请求的头部携带上这个令牌，来做相应的身份认证，所以自己在请求中做了这些改动（有标注），后端没改动，源码： 12345678910111213141516171819checkIdentity:function()&#123; let token =sessionStorage.getItem('token'); this.$http(&#123; method:'post', url:'http://localhost:8089/StockAnalyse/LoginServlet', params:&#123; "flag":"checklogin", "isLogin":true,"token":token &#125;, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded'， 'token':token //header中携带令牌信息 &#125;, credientials:false, emulateJSON: true &#125;).then(function(response)&#123; console.log(response.data); &#125;) &#125; 但实际上在devtools打印了如下错误信息：Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost‘ is therefore not allowed access.仔细想一想，好像，似乎这个问题遇到过，还提过问，确实提过，链接在这里。但这次的设置和上次一样，就在header里多加了一个自定义token，但却报了和上次没有设置headers: {‘Content-Type’: ‘application/x-www-form-urlencoded’}一样的错误信息，于是，不知所措，算了，重头再来，好好百度，研究一下cors跨域。 理论学习运气不错，找到了一篇好文，文章讲的很细，也找到自己问题的所在：触发 CORS 预检请求。引用原文的话加以自己总结：跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request：似曾相识有没有？诶，对，上面那个错误信息中，就有一个这样陌生的词汇），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。所以跨域请求分两种：简单请求和预检请求。一次完整的请求不需要服务端预检，直接响应的，归为简单请求；而响应前需要预检的，称为预检请求，只有预检请求通过，才有接下来的简单请求。对于那些是简单请求，那些会触发预检请求，文章做了详细的总结，这里列出触发预检请求的条件（不知道脑子为啥会想到那些会触发BFC的条件），不要跑题，原文是这样总结的： 12345678910111213141516171819202122当请求满足下述任一条件时，即应首先发送预检请求：使用了下面任一 HTTP 方法：PUTDELETECONNECTOPTIONSTRACEPATCH人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：AcceptAccept-LanguageContent-LanguageContent-Type (but note the additional requirements below)DPRDownlinkSave-DataViewport-WidthWidth Content-Type 的值不属于下列之一:application/x-www-form-urlencodedmultipart/form-datatext/plain 问题分析所以，对于自己的错误，无法将预检请求转变为简单请求，所以，只有寻找方法怎么在后端实现相应的预检请求，来返回一个状态码2xx，告诉浏览器此次跨域请求可以继续。所以注意力转向后端。关于JAVA实现预检请求，基本都是采用过滤器或者拦截器解决。 过滤器解决自定义（copy）了一个filter,并在web.xml中进行了设置。源码： Filter接口实现部分： 123456789101112131415161718192021222324252627282930313233package stock.model;import java.io.IOException; import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; import org.apache.commons.httpclient.HttpStatus; //这里需要添加commons-httpclient-3.1.jarpublic class CorsFilter implements Filter &#123; //filter 接口的自定义实现 public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpServletRequest request = (HttpServletRequest) servletRequest; response.setHeader("Access-Control-Allow-Origin", "*"); String token = request.getHeader("token"); System.out.println("filter origin:"+token);//通过打印，可以看到一次非简单请求，会被过滤两次，即请求两次，第一次请求确认是否符合跨域要求（预检），这一次是不带headers的自定义信息，第二次请求会携带自定义信息。 if ("OPTIONS".equals(request.getMethod()))&#123;//这里通过判断请求的方法，判断此次是否是预检请求，如果是，立即返回一个204状态吗，标示，允许跨域；预检后，正式请求，这个方法参数就是我们设置的post了 response.setStatus(HttpStatus.SC_NO_CONTENT); //HttpStatus.SC_NO_CONTENT = 204 response.setHeader("Access-Control-Allow-Methods", "POST, GET, DELETE, OPTIONS, DELETE");//当判定为预检请求后，设定允许请求的方法 response.setHeader("Access-Control-Allow-Headers", "Content-Type, x-requested-with, Token"); //当判定为预检请求后，设定允许请求的头部类型 response.addHeader("Access-Control-Max-Age", "1"); &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678&lt;filter&gt;&lt;filter-name&gt;cors&lt;/filter-name&gt;&lt;filter-class&gt;stock.model.CorsFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;cors&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 拦截器解决使用拦截器将所有请求拦截下来，如果是预检请求则返回请求通过的状态码2XX，如果不是则检验header头里token字段是否合法，不合法则拦截并返回token不合法的状态码，合法则将请求放行至cotroller层处理。 拦截器源码Interceptor.java： 12345678910111213141516public class Interceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //第一次预检请求都过 if (request.getMethod().equals("OPTIONS")) &#123;//如果是第一次预检请求 response.setStatus(HttpServletResponse.SC_OK);//直接返回请求成功的状态 return true;//拦截返回后端 &#125; setCrossDomain(response); return checkToken(request,response);//检验token是否合法 &#125;&#125; 配置拦截器Configation.java： 12345678910111213141516171819202122232425262728package com.carshop.server.interceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class Configation extends WebMvcConfigurerAdapter &#123; @Bean public HandlerInterceptor getInterceptor()&#123; return new Interceptor(); &#125; //注册拦截器2 @Override public void addInterceptors(InterceptorRegistry registry) &#123; /*addPathPatterns 用于添加拦截规则 excludePathPatterns 用户排除拦截*/ registry.addInterceptor(getInterceptor()).addPathPatterns("/**") .excludePathPatterns("/user/register"); &#125;&#125; 结论当在后端实现添加上面的源码后，皆大欢喜，问题得以解决，补上失败和成功,自己截下的两张请求响应图。 请求失败 请求成功 仔细看请求响应失败发起响应那张图，在General的数据集中，可以看到方法是options，而非代码指定的post请求，所以这是一次浏览器发出的一次预检请求，让服务器确认此IP是否有访问的权限，如果有，服务器需要返回一个2xx的状态码给浏览器。紧接着再发起一次简单请求。如下面在devtools中的截取图片（为了对比清除，我把两次分别截取，做了拼接，因为不会做动态图）。可以看到同一个post请求，实际上产生了两次网络连接。 但关于CORS,要去探索的，还有很多很多，所以遵循革命语录：实践（有时也可以是时间）是检验真理的唯一标准，是没有错的。后续有新的收获，再补充。 具体源代码详见GithubGithub-CarShop]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Token生成]]></title>
    <url>%2Fdevelopment%2Fvue-token%2F</url>
    <content type="text"><![CDATA[最近在做数据库课程设计，我是做前端的，后端并不是很懂，看vue这个框架仅仅只是入门，所以这篇文章写的可能不怎么好，仅作记录，有什么不对或不足的地方欢迎大神指出。 问题做一个登录界面，我选择的是用token进行验证登录，我用的前端框架是Vue.js 和 element-ui,如何在vue 中使用token进行验证登录 思考1、利用token进行验证登录，用户进行登录操作时，后台会生成一个token返回给前端，由前端 将这个token放到请求头中（这个是百度的，一般都是放在请求头），并且此后调用接口都要把token放到请求的请求头传回给后台。2、用户登录后，前端需要把token保存下来,后面发送请求的时候在拿出来；3、在发送每个请求时都要把token加到请求头里，写一个全局的拦截器 记录和说明使用vuex存储登录状态并用cookie存储token 在src文件夹(我的vue项目是用vue-cli 脚手架创建的)下创建一个store文件夹，在store中创建一个index.js src/store/index.js 12345678910111213141516171819202122232425262728import Vue from 'vue'import Vuex from 'vuex'import user from './modules/user'import app from './modules/app'import chat from './modules/chat'import getters from './getters'//用sessionStorage使vuex持久化，保存至本次回话结束，防止刷新导致前端反复向后端请求数据const handleStore = store =&gt; &#123; if (sessionStorage.store) store.replaceState(JSON.parse(sessionStorage.store)) // 初始化store store.subscribe((mutation, state) =&gt; &#123; sessionStorage.setItem("store", JSON.stringify(state)) &#125;)&#125;Vue.use(Vuex)const store = new Vuex.Store(&#123; modules: &#123; chat, app, user, &#125;, getters, plugins: [handleStore]&#125;)export default store src/store/module/user.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import &#123; loginById,loginByToken, logout, getUserInfo,checkSession,changePassword, register&#125; from '@/api/user'import &#123; getToken, setToken, removeToken &#125; from '@/utils/auth'import &#123;setSecret,changePasswordBySecret,checkHaveSecret&#125; from "@/api/security";import &#123;baseUrl&#125; from "@/api";import &#123;editUser&#125; from "@/api/admin";const defaultAvatar=baseUrl+'/UserAvatar/default_avatar.png'const user = &#123; state: &#123; id: '', token: getToken('token'), name: '', sex:'', phone:'', loc:'', role: '', avatar: '', brandId:'', status: false, secretStatus:false &#125;, mutations: &#123; SET_USER:(state,info)=&gt;&#123; if(info.role==='normal')&#123; state.id=info.data.id state.name = info.data.name===null?"User":info.data.name state.sex = info.data.sex state.loc = info.data.loc state.avatar = info.data.avatar===null?defaultAvatar:baseUrl+info.data.avatar &#125; else if(info.role==='admin' || info.role==='superAdmin')&#123; state.id = info.data.shopId state.name = info.data.shopName===null?"admin":info.data.shopName state.brandId=info.data.brand.brandId state.avatar = info.data.brand.logo===null?defaultAvatar:baseUrl+info.data.brand.logo &#125; state.token = info.data.token state.phone = info.data.phone state.role = info.role state.status = true &#125;, CLEAR_USER:(state)=&gt;&#123; state.id='' state.token = '' state.name = '' state.sex = '' state.phone = '' state.loc = '' state.role = '' state.avatar = '' state.status = false state.brandId = '' &#125; &#125;, actions: &#123; //用户信息状态初始化 UserInfoInit(&#123;commit&#125;)&#123; return new Promise(resolve =&gt; &#123; commit('CLEAR_USER') resolve() &#125;) &#125;, // 用户名登录 loginById(&#123; commit &#125;, loginInfo) &#123; const id = loginInfo.id.trim() return new Promise((resolve, reject) =&gt; &#123; loginById(id, loginInfo.encryptPassword,loginInfo.role).then(data =&gt; &#123; if(data.code===401) reject("用户名或密码错误") else if(data.code===402) reject("用户名不存在") else if(data.code===400)&#123; if(data.role==='admin'||data.role==='superAdmin') commit('SET_SECRET_STATUS',true) else &#123; checkHaveSecret(id).then(response=&gt;&#123; commit('SET_SECRET_STATUS',response==='success') &#125;) &#125; commit('SET_USER',data) setToken('token',data.data.token) if(loginInfo.radio==='1')&#123; setToken('id',id) setToken('password',loginInfo.password) setToken('role',loginInfo.role) &#125;else&#123; removeToken('id') removeToken('password') removeToken('role') &#125; &#125; resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125; &#125;&#125;export default user 说明：（1）在写src/store/index.js 里的内容之前，要在你的项目里安装Vuex ，这里只提供npm的安装方法，在项目根目录处打开cmd 输入下面的命令，后回车 npm install vuex --save （2） 在这个store/store/index.js中 这段代码setToken，removeToken这两个函数源码为： 12345678910111213141516171819import Cookies from 'js-cookie'import &#123;encryptMd5&#125; from '@/utils/encrypt'/*const TokenKey = 'Admin-Token'*/export function getToken(TokenKey) &#123; return Cookies.get(TokenKey)&#125;export function setToken(TokenKey,token) &#123; if(TokenKey==='token') return Cookies.set(TokenKey, token,&#123; expires:1 &#125;) else return Cookies.set(TokenKey, token,&#123;expires:3&#125;)&#125;export function removeToken(TonkenKey) &#123; return Cookies.remove(TonkenKey)&#125; 定义全局拦截器和Ajax请求对象 src/main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import axios from 'axios'import &#123; Message,MessageBox &#125; from 'element-ui'import store from '@/store'import &#123; getToken &#125; from '@/utils/auth'import &#123; baseUrl &#125; from '@/api'const tokenBlankList=['/user/register','/car/get']// 创建axios实例const service = axios.create(&#123; baseURL: baseUrl, // api 的 base_url=”http://localhost:8080“ timeout: 5000 // request timeout&#125;)// request拦截器service.interceptors.request.use( config =&gt; &#123; // 发送请求时添加配置信息 if(config.headers['Content-Type']==='application/json') config.data = JSON.stringify(config.data); if (tokenBlankList.indexOf(config.url)===-1&amp;&amp;getToken('token')&amp;&amp;typeof(getToken('token'))!=="undefined") &#123; // 让每个请求携带token-- ['X-Token']为自定义key 请根据实际情况自行修改 config.headers['Token'] = getToken('token') &#125; return config &#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error) &#125;)// response拦截器service.interceptors.response.use( /** * 下面的注释为通过在response里，自定义code来标示请求状态 * 当code返回如下情况则说明权限有问题，登出并返回到登录页 * 如想通过 xmlhttprequest 来状态码标识 逻辑可写在下面error中 * 以下代码均为样例，请结合自生需求加以修改，若不需要，则可删除 */ response =&gt; &#123; const res = response.data //404:非法的token; 403:其他客户端登录了; 50014:Token 过期了; if (res.code === 404 || res.code === 403 || res.code === 402) &#123; //请自行在引入 MessageBox //import &#123; Message, MessageBox &#125; from 'element-ui' MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', &#123; confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; location.reload() //为了重新实例化vue-router对象 避免bug &#125;) &#125;) return Promise.reject('error') &#125; else if(res.code===400) &#123; return res.datas &#125; &#125;, error =&gt; &#123; console.log(error) // for debug Message(&#123; message: error.message, type: 'error', duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)export default service 说明 这个是全部的代码，不一定都和这个一样，下面说说用token验证，src/main.js中要配置那些东西说明 具体前端代码 src/components/login.vue 12345678910111213141516171819onLogin()&#123; //数据格式验证完毕，实现登录功能 if(!this.$refs.Verity.isPassing)&#123; this.$message.error(&#123; message:"验证失败,请拉拽到右边以验证", showClose:true &#125;); return &#125;else&#123; this.loginForm.encryptPassword=encryptMd5(this.loginForm.password) this.$store.dispatch('loginById', this.loginForm).catch((err) =&gt; &#123; this.$message.error(&#123; message:err,/*"登录失败,请检查后重试"*/ showClose:true &#125;) &#125;) &#125; this.props.show=false;&#125; 具体源代码详见GithubGithub-CarShop]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fdevelopment%2Fgit%2F</url>
    <content type="text"><![CDATA[实际项目开发中，我们经常会用一些版本控制器来托管自己的代码，今天就来总结下Git的相关用法 git工具下载安装git命令使用详解git基本信息配置123git config -- global user.name &apos;你再github上注册的用户名&apos;;//设置用户名git config -- global user.email &apos;注册时候的邮箱&apos;; //设置用户邮箱git config --list //配置ok之后，我们用如下命令来看看是否配置成功 SSH密钥创建初始化一个git仓库 创建文件夹 方法一:可以鼠标右键&gt;点击新建文件夹 方法二:使用命令mkdir &lt;floder name&gt; 在文件夹内初始化git12cd &lt;floder name&gt; //进入刚创建的文件夹目录git init //使用git初始化该文件夹 向git仓库里添加文件 方法一:直接在该文件夹内右键鼠标创建文件或文件夹 方法二:使用命令touch &lt;file name&gt;创建文件 git克隆远程仓库克隆默认分支1git clone &lt;仓库地址&gt; 克隆指定分支1git clone -b &lt;仓库指定分支&gt; &lt;仓库地址&gt; git本地仓库同步到远程仓库 查看仓库状态: 1git status 添加到暂存区: 1git add &lt;文件名&gt; //若是添加所有文件直接输入git add . 提交到本地仓库: 1git commit -m `&lt;提交信息&gt;` 由本地仓库push到远程仓库 1git push //上传到指定分支git push origin &lt;指定分支&gt; 错误解决方法: 出现提交错误信息 12git commit -m `&lt;提交信息&gt;`fatal: could not open `.git/COMMIT_EDITMSG`: Permisssion denide 解决:这是通过Git GUI进行提交时发生的错误，由 .git 文件夹中的文件被设为“只读”所致，将 .git 文件夹下的所有文件、文件夹及其子文件的只读属性去掉即可. 如果出现无法同步或没有权限解决:用户名和密码一定要和github上的一致. 分支管理查看分支12345git branch -a* hexo //显示我们正处于hexo分支下 remotes/origin/HEAD -&gt; origin/master//显示默认分支 remotes/origin/hexo remotes/origin/master//其他两个分支 创建分支1git checkout -b &lt;创建分支&gt; git checkout命令加上-b参数表示创建并切换,相当于以下两条命令:12git branch &lt;创建分支&gt;git checkout &lt;创建分支&gt; 然后可以使用git branch -a查看当前分支,验证是否创建成功.最后再同步到远程仓库即可 删除分支1git push origin --delete &lt;指定分支&gt;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中pip的使用]]></title>
    <url>%2Fdevelopment%2Fpip%2F</url>
    <content type="text"><![CDATA[在python的学习过程中，肯定会遇到很多安装模块的地方，可以使用easy_install安装，但是easy_install相对于pip而言，最大的缺陷就是它所安装的模块是不能够卸载的，其他功能是和pip一样的。 下载安装pip下载pip下载pip安装py脚本 右键另存为或者直接运行命令1curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 安装pip1python get-pip.py pip使用详解pip安装模块包123pip install &lt;package name&gt; //使用命令安装[...]successfully installed &lt;package-name&gt; pip查看已安装的包列表1234pip list //显示已安装包列表Package Version------- -------[...] pip检查那些包需要更新1234pip list --outdated //显示需要更新的包Package Version Latest Type------- ------- ------ -----[...] pip更新包1234567pip install --upgrade &lt;package name&gt;[...]Installing collected packages: &lt;package name&gt; Found existing installation: &lt;old version package name&gt; Uninstalling &lt;old version package name&gt; Successfully uninstalled &lt;new version package name&gt;Successfully installed &lt;new version package name&gt; pip卸载包12345pip uninstall &lt;package name&gt;Uninstalling &lt;package name&gt;: Would remove: [,,,]Proceed (y/n)?]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2Fshare%2Fhexo-establish%2F</url>
    <content type="text"><![CDATA[Github+Hexo搭建博客 博客搭建准备环境 Node.js下载并安装 Git下载并安装 安装Hexo，在命令行（即Git Bash）内输入命令：$ npm install -g hexo-cli 初始化Hexo，并安装其依赖包在命令行（即Git Bash）中输入命令： 123$ hexo init &lt;floder&gt;$ cd &lt;floder&gt;$ npm install 新建完成后，在路径下（即），会产生以下文件和文件夹 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 ​ 路径为_config.yml` 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。​ 路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：hexo server //也可简写为 hexo s 浏览器访问：http://localhost:4000/ 主题优化选择主题Hexo默认主题为landscape，推荐以下主题： snippet next BlueLake Jsimple 更多主题详见(https://github.com/search?q=hexo-theme) 应用主题 下载主题 将下载好的主题文件夹复制到站点目录下的themes文件夹下。 更改站点配置文件_config.yml的theme字段，更改为主题文件夹名称： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt; 主题优化添加背景图在 themes/&lt;thenme floder&gt;/source/css/_custom/custom.styl 中添加如下代码：1234567body&#123; background:url(/images/bg.jpg); //背景图片所在目录 background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 修改Logo字体在 themes/&lt;theme floder&gt;/source/css/_custom/custom.styl 中添加如下代码：12345678@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;); &#125;//导入自定义字体 .site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important; &#125;//应用字体到Logo 自定义鼠标样式打开themes/&lt;theme floder&gt;/source/css/_custom/custom.styl,在里面写下如下代码：1234567// 鼠标样式 * &#123; cursor: url(&quot;/images/cursor.ico&quot;),auto!important //将鼠标样式icon图片放置于themes\next\source\images目录下 &#125; :active &#123; cursor: url(&quot;/images/cursor_active.ico&quot;),auto!important //将鼠标激活样式icon图片放置于themes\next\source\images目录下 &#125; 注： 鼠标样式图片格式必须为icon 修改访问URL路径默认情况下访问URL路径为：domain/2019/01/23/hexo-establish,修改为domain/share/hexo-establish。 编辑 Hexo 站点下的_config.yml文件，修改其中的permalink字段：1permalink: :category/:title/ 博文置顶 安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top即可： 123456---title: 2019date: 2019-01-23 16:10:03top: 10--- 设置置顶标志打开：/themes/&lt;theme floder&gt;/layout/_macro/post.swig，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下,插入以下代码即可： 12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 插件配置评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 livere 4 多种账号登陆 评论无法导出 畅言 3 美观 必须备份域名 Disqus 1 需要翻*墙 Valine1.1 获取APP ID和APP Key请先登陆或注册LearnCloud，进入控制台后点击创建应用，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2 填写APP ID 和 APP Key到主题配置文件_config.yml123456789101112131415# Valine# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true appid: hD6toShsJcsEQR6gT2iaw58b-gzGzoHsz appkey: Xn8ohIhFuwNcsDqVdPD6baA2 notify: true verify: false placeholder: ヾﾉ≧∀≦)o来啊，快活啊! //评论框内的水印文字 avatar: mm guest_info: nick,mail,link //评论所需信息 pageSize: 10 visitor: false comment_count: true 1.3 运行hexo g&amp;&amp;hexo d推送到博客。 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error 参数中包含冒号，请用加引号，如Last updated: %s 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” Server Problems1Error: listen EADDRINUSE 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置：1$ hexo server -p 5000 常用操作创建文章输入命令1$ hexo new [layout] &lt;title&gt; 参数说明 [layout]可以分为以下三种 参数名 功能 文章路径 post 新建博文 source/post page 新建页面(如404，标签等) source draft 草稿 source/draft 草稿可以通过以下命令发布1$ hexo publish [layout] &lt;title&gt; title不是博文标题，而是博文md文件名字。 文章模板 创建模板在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new blog “simon” 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文章建立日期]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Magisk]]></title>
    <url>%2Fdevelopment%2FMagisk%2F</url>
    <content type="text"><![CDATA[Magisk 简介Magisk，以不触动/system的方式修改/system，继Super SU systemless化后的新发展。 作者topjohnwu ,Github 特性介绍Magic Mount:此特性不仅允许用户替换/system目录下已经存在的文件及文件夹，同时也支持创建/system原本不存在的文件及文件夹。当然，实际上并不修改原来的/system.这意味之前的修改模块(zip刷机包)基本都可以在这种systemless-ly模式下工作。 Multiple Entry Points:如果“Magic Mount”还不能完成实现你的需求，Magisk在系统启动过程中提供了几个暂停点来运行你的脚本，使开发者可以在任何需要的时候实现所需的功能。在启动过程被暂停后，直到你的脚本被执行前，Magisk都可以可靠地阻断启动过程的继续。 Magisk Manager:Magisk Manager这款app可以帮助你管理root状态，以及管理所有的Magisk模块(模块管理功能还在开发中)，就像Xposed模块一样。 Special “Cache” Mode:这种模式支持在system props被加载前运行，这意味Magisk能更多的可能性。systemless hosts 默认开启，各种修改hosts的广告屏蔽软件无需修改就可以直接使用此systemless模式。Magisk还将会移除 system verify和 forceencrypt(二者均可以通过.magisk文件手动配置), 并且修改sepolicy使得脚本运行正常。这意味着开发者以后无需担心boot.img的修改问题。一些主要的系统修改，如root和Xposed等，都可以依赖于Magisk.magisk.img(所有systemless模块存储在此文件内)支持自动调节文件大小以适应较大体积模块，同时也可以在某些模块移除后自动缩小大小。 tips 建议配合phh’s SuperUser(原帖内附带的修改版)来使用，这样systemless特性最低支持到Android 5.0，同时还可以在开机后一键关闭root；Chainfire的SuperSU(使用原帖修改版)systemless最低支持5.1，暂不支持开机后一键关闭root。一键关闭root主要为了Android pay的使用，不使用Android pay的话这两种root方式没太大区别。 systemless Xposed需要对应版本呢，安装器对应material版。http://coolapk.com/r/2ord systemless ViPER4Android，原帖仅提供驱动systemless安装，刷入后在安装apk即可。 模块分享​]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Magisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fdevelopment%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到Hexo！这是你的第一篇文章。查看文档以获取更多信息。如果您在使用Hexo时遇到任何问题，可以在故障排除中找到答案，或者您可以在GitHub上询问我。 快速开始创建一个新帖子1$ hexo new "My New Post" 更多信息: Writing 运行服务1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
